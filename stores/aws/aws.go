package aws

import (
	"context"
	"encoding/json"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/credentials/stscreds"
	"github.com/aws/aws-sdk-go-v2/service/secretsmanager"
	"github.com/aws/aws-sdk-go-v2/service/secretsmanager/types"
	"github.com/aws/aws-sdk-go-v2/service/sts"
	"github.com/robertlestak/vault-secret-sync/pkg/driver"
	log "github.com/sirupsen/logrus"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type AwsClient struct {
	Name           string            `yaml:"name,omitempty" json:"name,omitempty"`
	RoleArn        string            `yaml:"roleArn,omitempty" json:"roleArn,omitempty"`
	Region         string            `yaml:"region,omitempty" json:"region,omitempty"`
	EncryptionKey  string            `yaml:"encryptionKey,omitempty" json:"encryptionKey,omitempty"`
	ReplicaRegions []string          `yaml:"replicaRegions,omitempty" json:"replicaRegions,omitempty"`
	Tags           map[string]string `yaml:"tags,omitempty" json:"tags,omitempty"`

	client *secretsmanager.Client `yaml:"-" json:"-"`

	accountSecretArns map[string]string `yaml:"-" json:"-"`
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AwsClient) DeepCopyInto(out *AwsClient) {
	*out = *in
	if in.ReplicaRegions != nil {
		in, out := &in.ReplicaRegions, &out.ReplicaRegions
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.accountSecretArns != nil {
		in, out := &in.accountSecretArns, &out.accountSecretArns
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AwsClient.
func (in *AwsClient) DeepCopy() *AwsClient {
	if in == nil {
		return nil
	}
	out := new(AwsClient)
	in.DeepCopyInto(out)
	return out
}

func (c *AwsClient) Validate() error {
	l := log.WithFields(log.Fields{
		"action": "Validate",
	})
	l.Trace("start")
	if c.Name == "" {
		return driver.ErrPathRequired
	}
	return nil
}

func NewClient(cfg *AwsClient) (*AwsClient, error) {
	l := log.WithFields(log.Fields{
		"action": "NewClient",
	})
	l.Trace("start")
	vc := &AwsClient{}
	jd, err := json.Marshal(cfg)
	if err != nil {
		l.Debugf("error: %v", err)
		return nil, err
	}
	err = json.Unmarshal(jd, &vc)
	if err != nil {
		l.Debugf("error: %v", err)
		return nil, err
	}
	if vc.Region == "" {
		vc.Region = "us-east-1"
	}
	l.Debugf("client=%+v", vc)
	l.Trace("end")
	return vc, nil

}

func (c *AwsClient) CreateClient(ctx context.Context) error {
	l := log.WithFields(log.Fields{
		"action": "CreateClient",
	})
	l.Trace("start")
	awscfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		l.Debugf("error: %v", err)
		return err
	}
	var provider aws.CredentialsProvider
	if c.RoleArn != "" {
		stsclient := sts.NewFromConfig(awscfg)
		provider = stscreds.NewAssumeRoleProvider(stsclient, c.RoleArn)
		awscfg.Credentials = provider
	}
	svc := secretsmanager.New(secretsmanager.Options{
		Region:      c.Region,
		Credentials: awscfg.Credentials,
	})
	c.client = svc
	l.Trace("end")
	return nil
}

func (vc *AwsClient) Meta() map[string]any {
	md := make(map[string]any)
	jd, err := json.Marshal(vc)
	if err != nil {
		return md
	}
	err = json.Unmarshal(jd, &md)
	if err != nil {
		return md
	}
	return md
}

func (g *AwsClient) Init(ctx context.Context) error {
	if err := g.CreateClient(ctx); err != nil {
		return err
	}
	if err := g.Validate(); err != nil {
		return err
	}
	if _, err := g.ListSecrets(ctx, ""); err != nil {
		return err
	}
	return nil
}
func (g *AwsClient) Driver() driver.DriverName {
	return driver.DriverNameAws
}
func (g *AwsClient) GetPath() string {
	return g.Name
}

func (g *AwsClient) GetSecret(ctx context.Context, name string) ([]byte, error) {
	l := log.WithFields(log.Fields{
		"action": "GetSecret",
	})
	l.Trace("start")
	defer l.Trace("end")
	arn := g.accountSecretArns[name]
	resp, err := g.client.GetSecretValue(ctx, &secretsmanager.GetSecretValueInput{
		SecretId: &arn,
	})
	if err != nil {
		l.Errorf("error: %v", err)
		return nil, err
	}
	return []byte(*resp.SecretString), nil
}

func (c *AwsClient) createSecret(ctx context.Context, name string, secret []byte) error {
	l := log.WithFields(log.Fields{
		"action": "createSecret",
		"name":   name,
		"driver": c.Driver(),
	})
	l.Trace("start")
	defer l.Trace("end")
	csi := &secretsmanager.CreateSecretInput{
		Name:         &name,
		Description:  aws.String("managed in HashiCorp Vault. do not edit directly."),
		SecretString: aws.String(string(secret)),
	}
	if c.EncryptionKey != "" {
		csi.KmsKeyId = aws.String(c.EncryptionKey)
	}
	if len(c.ReplicaRegions) > 0 {
		var rep []types.ReplicaRegionType
		for _, r := range c.ReplicaRegions {
			rr := types.ReplicaRegionType{
				Region: aws.String(r),
			}
			if c.EncryptionKey != "" {
				rr.KmsKeyId = aws.String(c.EncryptionKey)
			}
			rep = append(rep, rr)
		}
		csi.AddReplicaRegions = rep
	}
	if c.Tags != nil {
		var tags []types.Tag
		for k, v := range c.Tags {
			tags = append(tags, types.Tag{
				Key:   aws.String(k),
				Value: aws.String(v),
			})
		}
		csi.Tags = tags
	}
	_, err := c.client.CreateSecret(ctx, csi)
	if err != nil {
		l.Errorf("error: %v", err)
		return err
	}
	return nil
}

func (c *AwsClient) updateSecret(ctx context.Context, name string, secret []byte) error {
	l := log.WithFields(log.Fields{
		"action": "updateSecret",
		"name":   name,
		"driver": c.Driver(),
	})
	l.Trace("start")
	defer l.Trace("end")
	arn := c.accountSecretArns[name]
	usi := &secretsmanager.UpdateSecretInput{
		SecretId:     &arn,
		SecretString: aws.String(string(secret)),
	}
	if c.EncryptionKey != "" {
		usi.KmsKeyId = aws.String(c.EncryptionKey)
	}
	_, err := c.client.UpdateSecret(ctx, usi)
	if err != nil {
		l.Errorf("error: %v", err)
		return err
	}
	return nil
}

func (g *AwsClient) WriteSecret(ctx context.Context, meta metav1.ObjectMeta, path string, secrets []byte) ([]byte, error) {
	l := log.WithFields(log.Fields{
		"action": "WriteSecret",
		"driver": g.Driver(),
		"path":   path,
	})
	l.Trace("start")
	defer l.Trace("end")
	// if there is an existing secret, update it
	if _, ok := g.accountSecretArns[path]; ok {
		err := g.updateSecret(ctx, path, secrets)
		if err != nil {
			l.Errorf("error: %v", err)
			return nil, err
		}
	} else {
		err := g.createSecret(ctx, path, secrets)
		if err != nil {
			l.Errorf("error: %v", err)
			return nil, err
		}
	}
	return nil, nil
}

func (g *AwsClient) DeleteSecret(ctx context.Context, secret string) error {
	l := log.WithFields(log.Fields{
		"action": "DeleteSecret",
		"driver": g.Driver(),
		"path":   secret,
	})
	l.Trace("start")
	defer l.Trace("end")
	arn := g.accountSecretArns[secret]
	_, err := g.client.DeleteSecret(ctx, &secretsmanager.DeleteSecretInput{
		SecretId: &arn,
	})
	if err != nil {
		l.Errorf("error: %v", err)
		return err
	}
	return nil
}

func (g *AwsClient) ListSecrets(ctx context.Context, p string) ([]string, error) {
	l := log.WithFields(log.Fields{
		"action": "ListSecrets",
	})
	l.Trace("start")
	defer l.Trace("end")
	var secretsList []string
	var nextToken *string
	arnMap := make(map[string]string)
	for {
		params := &secretsmanager.ListSecretsInput{
			NextToken: nextToken,
		}
		resp, err := g.client.ListSecrets(ctx, params)
		if err != nil {
			l.Debugf("error: %v", err)
			return nil, err
		}
		for _, secret := range resp.SecretList {
			arnMap[*secret.Name] = *secret.ARN
			secretsList = append(secretsList, *secret.Name)
		}
		if resp.NextToken == nil {
			break
		}
		nextToken = resp.NextToken
	}
	g.accountSecretArns = arnMap
	return secretsList, nil
}

func (c *AwsClient) SetDefaults(defaults any) error {
	dv, err := json.Marshal(defaults)
	if err != nil {
		return err
	}
	dc := &AwsClient{}
	err = json.Unmarshal(dv, dc)
	if err != nil {
		return err
	}
	if c.Region == "" && dc.Region != "" {
		c.Region = dc.Region
	}
	if c.RoleArn == "" && dc.RoleArn != "" {
		c.RoleArn = dc.RoleArn
	}
	if c.EncryptionKey == "" && dc.EncryptionKey != "" {
		c.EncryptionKey = dc.EncryptionKey
	}
	if len(c.ReplicaRegions) == 0 && len(dc.ReplicaRegions) > 0 {
		c.ReplicaRegions = dc.ReplicaRegions
	}
	return nil
}

func (c *AwsClient) Close() error {
	c.client = nil
	return nil
}
