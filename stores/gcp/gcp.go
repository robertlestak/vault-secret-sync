package gcp

import (
	"context"
	"encoding/json"
	"fmt"
	"hash/crc32"
	"strings"

	secretmanager "cloud.google.com/go/secretmanager/apiv1"
	"cloud.google.com/go/secretmanager/apiv1/secretmanagerpb"
	"github.com/robertlestak/vault-secret-sync/pkg/driver"
	log "github.com/sirupsen/logrus"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type GcpClient struct {
	Project              string            `yaml:"project,omitempty" json:"project,omitempty"`
	Name                 string            `yaml:"name,omitempty" json:"name,omitempty"`
	ReplicationLocations []string          `yaml:"replicationLocations,omitempty" json:"replicationLocations,omitempty"`
	Labels               map[string]string `yaml:"labels,omitempty" json:"labels,omitempty"`

	client *secretmanager.Client `yaml:"-" json:"-"`
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GcpClient) DeepCopyInto(out *GcpClient) {
	*out = *in
	if in.ReplicationLocations != nil {
		in, out := &in.ReplicationLocations, &out.ReplicationLocations
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GcpClient.
func (in *GcpClient) DeepCopy() *GcpClient {
	if in == nil {
		return nil
	}
	out := new(GcpClient)
	in.DeepCopyInto(out)
	return out
}

func (c *GcpClient) Validate() error {
	l := log.WithFields(log.Fields{
		"action": "Validate",
	})
	l.Trace("start")
	if c.Name == "" {
		return driver.ErrPathRequired
	}
	return nil
}

func NewClient(cfg *GcpClient) (*GcpClient, error) {
	l := log.WithFields(log.Fields{
		"action": "NewClient",
	})
	l.Trace("start")
	vc := &GcpClient{}
	jd, err := json.Marshal(cfg)
	if err != nil {
		l.Debugf("error: %v", err)
		return nil, err
	}
	err = json.Unmarshal(jd, &vc)
	if err != nil {
		l.Debugf("error: %v", err)
		return nil, err
	}
	l.Debugf("client=%+v", vc)
	l.Trace("end")
	return vc, nil

}

func (c *GcpClient) CreateClient(ctx context.Context) error {
	l := log.WithFields(log.Fields{
		"action": "CreateClient",
	})
	l.Trace("start")
	client, err := secretmanager.NewClient(ctx)
	if err != nil {
		log.Fatalf("failed to setup client: %v", err)
	}
	c.client = client
	l.Trace("end")
	return nil
}

func (vc *GcpClient) Meta() map[string]any {
	md := make(map[string]any)
	jd, err := json.Marshal(vc)
	if err != nil {
		return md
	}
	err = json.Unmarshal(jd, &md)
	if err != nil {
		return md
	}
	return md
}

func (g *GcpClient) Init(ctx context.Context) error {
	if err := g.CreateClient(ctx); err != nil {
		return err
	}
	if err := g.Validate(); err != nil {
		return err
	}
	if _, err := g.ListSecrets(ctx, ""); err != nil {
		return err
	}
	return nil
}
func (g *GcpClient) Driver() driver.DriverName {
	return driver.DriverNameGcp
}
func (g *GcpClient) GetPath() string {
	return g.Name
}

func (g *GcpClient) GetSecret(ctx context.Context, name string) ([]byte, error) {
	l := log.WithFields(log.Fields{
		"action": "GetSecret",
	})
	l.Trace("start")
	defer l.Trace("end")
	sv, err := g.client.AccessSecretVersion(ctx, &secretmanagerpb.AccessSecretVersionRequest{
		Name: g.fullName(name),
	})
	if err != nil {
		l.Errorf("error: %v", err)
		return nil, err
	}
	return sv.Payload.Data, nil
}

func (c *GcpClient) createSecretVersion(ctx context.Context, name string, secret []byte) error {
	l := log.WithFields(log.Fields{
		"action":   "createSecretVersion",
		"name":     name,
		"fullName": c.fullName(name),
		"driver":   c.Driver(),
	})
	l.Trace("start")
	defer l.Trace("end")
	secretString := secret
	crc32c := crc32.MakeTable(crc32.Castagnoli)
	checksum := int64(crc32.Checksum(secretString, crc32c))
	_, err := c.client.AddSecretVersion(ctx, &secretmanagerpb.AddSecretVersionRequest{
		// parent := "projects/my-project/secrets/my-secret"
		Parent: c.fullName(name),
		Payload: &secretmanagerpb.SecretPayload{
			Data:       secretString,
			DataCrc32C: &checksum,
		},
	})
	if err != nil {
		l.Errorf("error: %v", err)
		return err
	}
	return nil
}

func (c *GcpClient) createSecretWrapper(ctx context.Context, name string) error {
	l := log.WithFields(log.Fields{
		"action":   "createSecretWrapper",
		"name":     name,
		"fullName": c.fullName(name),
		"driver":   c.Driver(),
	})
	l.Trace("start")
	defer l.Trace("end")
	sd := &secretmanagerpb.Secret{}
	// add a label indicating this secret is managed by the event bus
	sd.Labels = map[string]string{
		"managed-by": "vault-secret-sync",
	}
	// add any additional user-provided labels
	for k, v := range c.Labels {
		sd.Labels[k] = v
	}
	if len(c.ReplicationLocations) == 0 {
		sd.Replication = &secretmanagerpb.Replication{
			Replication: &secretmanagerpb.Replication_Automatic_{
				Automatic: &secretmanagerpb.Replication_Automatic{},
			},
		}
	} else {
		var umrs []*secretmanagerpb.Replication_UserManaged_Replica
		for _, rl := range c.ReplicationLocations {
			umrs = append(umrs, &secretmanagerpb.Replication_UserManaged_Replica{
				Location: rl,
			})
		}
		sd.Replication = &secretmanagerpb.Replication{
			Replication: &secretmanagerpb.Replication_UserManaged_{
				UserManaged: &secretmanagerpb.Replication_UserManaged{
					Replicas: umrs,
				},
			},
		}
	}
	_, err := c.client.CreateSecret(ctx, &secretmanagerpb.CreateSecretRequest{
		Parent:   "projects/" + c.Project,
		SecretId: c.cleanName(name),
		Secret:   sd,
	})
	if err != nil {
		l.Errorf("error: %v", err)
		return err
	}
	return nil
}

func (g *GcpClient) cleanName(name string) string {
	return strings.ReplaceAll(name, "/", "-")
}

func (c *GcpClient) fullName(name string) string {
	if name == "" {
		name = c.Name
	}
	return fmt.Sprintf("projects/%s/secrets/%s", c.Project, c.cleanName(name))
}

func (c *GcpClient) createSecret(ctx context.Context, name string, secret []byte) error {
	l := log.WithFields(log.Fields{
		"action":   "createSecret",
		"name":     name,
		"fullName": c.fullName(name),
		"driver":   c.Driver(),
	})
	l.Trace("start")
	defer l.Trace("end")
	var err error
	// check if secret exists, if so create a new version
	// if not create a new secret
	_, err = c.client.GetSecret(ctx, &secretmanagerpb.GetSecretRequest{
		Name: c.fullName(name),
	})
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			l.WithError(err).Trace("secret not found")
			// create secret
			if err := c.createSecretWrapper(ctx, name); err != nil {
				return err
			}
		} else {
			l.WithError(err).Trace("error getting secret")
			return err
		}
	}
	if err := c.createSecretVersion(ctx, name, secret); err != nil {
		return err
	}
	return nil
}

func (c *GcpClient) updateSecret(ctx context.Context, name string, secret map[string]any) error {
	l := log.WithFields(log.Fields{
		"action":   "updateSecret",
		"name":     name,
		"fullName": c.fullName(name),
		"driver":   c.Driver(),
	})
	l.Trace("start")
	defer l.Trace("end")
	secretString, err := json.Marshal(secret)
	if err != nil {
		l.Errorf("error: %v", err)
		return err
	}
	// parent := "projects/my-project/secrets/my-secret"
	crc32c := crc32.MakeTable(crc32.Castagnoli)
	checksum := int64(crc32.Checksum(secretString, crc32c))

	req := &secretmanagerpb.AddSecretVersionRequest{
		Parent: c.fullName(name),
		Payload: &secretmanagerpb.SecretPayload{
			Data:       secretString,
			DataCrc32C: &checksum,
		},
	}
	result, err := c.client.AddSecretVersion(ctx, req)
	if err != nil {
		return fmt.Errorf("failed to add secret version: %w", err)
	}
	l.WithField("result", result).Trace("end")
	return nil
}

func (g *GcpClient) WriteSecret(ctx context.Context, meta metav1.ObjectMeta, path string, secrets []byte) ([]byte, error) {
	l := log.WithFields(log.Fields{
		"action":   "WriteSecret",
		"driver":   g.Driver(),
		"path":     path,
		"fullName": g.fullName(path),
	})
	l.Trace("start")
	defer l.Trace("end")
	if err := g.createSecret(ctx, path, secrets); err != nil {
		return nil, err
	}
	return nil, nil
}

func (g *GcpClient) DeleteSecret(ctx context.Context, secret string) error {
	l := log.WithFields(log.Fields{
		"action":   "DeleteSecret",
		"secret":   secret,
		"driver":   g.Driver(),
		"fullName": g.fullName(secret),
	})
	l.Trace("start")
	defer l.Trace("end")
	if err := g.client.DeleteSecret(ctx, &secretmanagerpb.DeleteSecretRequest{
		Name: g.fullName(secret),
	}); err != nil {
		l.Errorf("error: %v", err)
		return err
	}
	return nil
}

func (g *GcpClient) ListSecrets(ctx context.Context, p string) ([]string, error) {
	l := log.WithFields(log.Fields{
		"action": "ListSecrets",
	})
	l.Trace("start")
	defer l.Trace("end")
	var secretsList []string
	req := &secretmanagerpb.ListSecretsRequest{
		Parent: "projects/" + g.Project,
	}
	it := g.client.ListSecrets(ctx, req)
	for {
		resp, err := it.Next()
		if err == nil {
			// output is in format
			// projects/my-project/secrets/my-secret
			// split on / and get the last element
			// this is the secret name
			parts := strings.Split(resp.Name, "/")
			secretsList = append(secretsList, parts[len(parts)-1])
		} else {
			break
		}
	}
	l.WithField("secrets", secretsList).Trace("end")
	return secretsList, nil
}

func (g *GcpClient) Close() error {
	l := log.WithFields(log.Fields{
		"action": "Close",
	})
	l.Trace("start")
	defer l.Trace("end")
	if err := g.client.Close(); err != nil {
		l.Errorf("error: %v", err)
		return err
	}
	return nil
}

func (g *GcpClient) SetDefaults(defaults any) error {
	l := log.WithFields(log.Fields{
		"action": "SetDefaults",
	})
	l.Trace("start")
	defer l.Trace("end")
	jd, err := json.Marshal(defaults)
	if err != nil {
		return err
	}
	nc := &GcpClient{}
	err = json.Unmarshal(jd, nc)
	if err != nil {
		return err
	}
	if g.Project == "" && nc.Project != "" {
		g.Project = nc.Project
	}
	if g.Name == "" && nc.Name != "" {
		g.Name = nc.Name
	}
	if len(g.ReplicationLocations) == 0 && len(nc.ReplicationLocations) > 0 {
		g.ReplicationLocations = nc.ReplicationLocations
	}
	return nil
}
