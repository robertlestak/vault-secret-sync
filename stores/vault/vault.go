package vault

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/robertlestak/vault-secret-sync/pkg/driver"
	log "github.com/sirupsen/logrus"

	"github.com/hashicorp/vault/api"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// VaultClient is a single self-contained vault client
type VaultClient struct {
	Path       string `yaml:"path,omitempty" json:"path,omitempty"`
	Address    string `yaml:"address,omitempty" json:"address,omitempty"`
	CIDR       string `yaml:"cidr,omitempty" json:"cidr,omitempty"`
	AuthMethod string `yaml:"authMethod,omitempty" json:"authMethod,omitempty"`
	Namespace  string `yaml:"namespace,omitempty" json:"namespace,omitempty"`
	TTL        string `yaml:"ttl,omitempty" json:"ttl,omitempty"`
	Merge      bool   `yaml:"merge,omitempty" json:"merge,omitempty"`

	Role string `yaml:"role,omitempty" json:"role,omitempty"`

	Client *api.Client `yaml:"-" json:"-"`
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VaultClient) DeepCopyInto(out *VaultClient) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VaultClient.
func (in *VaultClient) DeepCopy() *VaultClient {
	if in == nil {
		return nil
	}
	out := new(VaultClient)
	in.DeepCopyInto(out)
	return out
}

func (c *VaultClient) Validate() error {
	l := log.WithFields(log.Fields{
		"action": "Validate",
	})
	l.Trace("start")
	if c.Address == "" {
		return errors.New("address required")
	}
	return nil
}

func NewClient(cfg *VaultClient) (*VaultClient, error) {
	l := log.WithFields(log.Fields{
		"action": "NewClient",
	})
	l.Trace("start")
	vc := &VaultClient{}
	jd, err := json.Marshal(cfg)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(jd, &vc)
	if err != nil {
		return nil, err
	}
	l.Tracef("client=%+v", vc)
	l.Trace("end")
	return vc, nil
}

func (vc *VaultClient) Meta() map[string]any {
	md := make(map[string]any)
	jd, err := json.Marshal(vc)
	if err != nil {
		return md
	}
	err = json.Unmarshal(jd, &md)
	if err != nil {
		return md
	}
	return md
}

func (vc *VaultClient) Driver() driver.DriverName {
	return driver.DriverNameVault
}

func (vc *VaultClient) GetPath() string {
	return vc.Path
}

// NewClients creates and returns a new vault client with a valid token or error
func (vc *VaultClient) NewClient(ctx context.Context) (*api.Client, error) {
	log.Tracef("vault.NewClient")
	config := &api.Config{
		Address: vc.Address,
	}
	var err error
	vc.Client, err = api.NewClient(config)
	if err != nil {
		return vc.Client, err
	}
	if vc.Namespace != "" {
		vc.Client.SetNamespace(vc.Namespace)
	}
	terr := vc.NewToken(ctx)
	if terr != nil {
		return vc.Client, terr
	}
	vc.Client.AddHeader("x-vault-sync", "true")
	return vc.Client, err
}

// Login creates a vault token with the k8s auth provider
func (vc *VaultClient) Login(ctx context.Context) error {
	l := log.WithFields(log.Fields{
		"address":   vc.Address,
		"role":      vc.Role,
		"path":      vc.Path,
		"method":    vc.AuthMethod,
		"namespace": vc.Namespace,
	})
	l.Trace("vault.Login")
	if vc.Client == nil {
		_, err := vc.NewClient(ctx)
		if err != nil {
			return err
		}
	}
	var kubeTokenExists bool
	ktp := "/var/run/secrets/kubernetes.io/serviceaccount/token"
	if _, err := os.Stat(ktp); !os.IsNotExist(err) {
		l.Tracef("kubeToken exists at path=%s", ktp)
		kubeTokenExists = true
	}
	var kt string
	if kubeTokenExists {
		l.Tracef("reading kubeToken from path=%s", ktp)
		fd, err := os.ReadFile(ktp)
		if err != nil {
			return err
		}
		kt = string(fd)
	}
	if kt != "" {
		options := map[string]interface{}{
			"role": vc.Role,
			"jwt":  kt,
		}
		if vc.TTL != "" {
			options["ttl"] = vc.TTL
		}
		path := fmt.Sprintf("auth/%s/login", vc.AuthMethod)
		l.WithFields(log.Fields{
			"path": path,
			"role": vc.Role,
		}).Trace("vault.Login calling Write")
		secret, err := vc.Client.Logical().WriteWithContext(ctx, path, options)
		if err != nil {
			return err
		}
		vc.Client.SetToken(secret.Auth.ClientToken)
	} else {
		vc.Client.SetToken(os.Getenv("VAULT_TOKEN"))
	}
	return nil
}

func tokenEnvTemplate(t string) string {
	l := log.WithFields(log.Fields{
		"action": "tokenEnvTemplate",
	})
	l.Trace("start")
	if !strings.Contains(t, "{{") {
		return ""
	}
	evs := strings.Split(t, "{{")
	if len(evs) < 2 {
		return ""
	}
	evs = strings.Split(strings.TrimSpace(evs[1]), "}}")
	if len(evs) < 2 {
		return ""
	}
	ev := evs[0]
	return os.Getenv(ev)
}

func (vc *VaultClient) Init(ctx context.Context) error {
	if err := vc.NewToken(ctx); err != nil {
		return err
	}
	if err := vc.Validate(); err != nil {
		return err
	}
	return nil
}

func (vc *VaultClient) NewToken(ctx context.Context) error {
	l := log.WithFields(log.Fields{
		"address": vc.Address,
		"role":    vc.Role,
		"path":    vc.Path,
		"method":  vc.AuthMethod,
	})
	l.Trace("vault.NewToken calling Login")
	if os.Getenv("VAULT_TOKEN") != "" {
		l.Trace("using VAULT_TOKEN")
		if vc.Client == nil {
			_, err := vc.NewClient(ctx)
			if err != nil {
				return err
			}
		}
		vc.Client.SetToken(os.Getenv("VAULT_TOKEN"))
	}
	if err := vc.Login(ctx); err != nil {
		return err
	}
	return nil
}

func insertSliceString(a []string, index int, value string) []string {
	if len(a) == index { // nil or empty slice or after last element
		return append(a, value)
	}
	a = append(a[:index+1], a[index:]...) // index < len(a)
	a[index] = value
	return a
}

// GetKVSecret retrieves a kv secret from vault
func (vc *VaultClient) GetKVSecretOnce(ctx context.Context, s string) (map[string]interface{}, error) {
	l := log.WithFields(log.Fields{
		"address": vc.Address,
		"role":    vc.Role,
		"path":    s,
		"method":  vc.AuthMethod,
	})
	var secrets map[string]interface{}
	if s == "" {
		return secrets, errors.New("secret path required")
	}
	ss := strings.Split(s, "/")
	if len(ss) < 2 {
		return secrets, errors.New("secret path must be in kv/path/to/secret format")
	}
	ss = insertSliceString(ss, 1, "data")
	//log.Debugf("headers_sent=%+v", vc.Client.Headers())
	c := vc.Client.Logical()
	s = strings.Join(ss, "/")
	if c == nil {
		return secrets, errors.New("vault client not initialized")
	}
	secret, err := c.ReadWithContext(ctx, s)
	if err != nil {
		return secrets, err
	}
	if secret == nil || secret.Data == nil {
		return nil, errors.New("secret not found: " + s)
	}
	l.Tracef("secret=%+v", secret)
	if secret.Data["data"] == nil {
		return nil, errors.New("secret data not found: " + s)
	}
	return secret.Data["data"].(map[string]interface{}), nil
}

// GetKVSecret will login and retry secret access on failure
// to gracefully handle token expiration
func (vc *VaultClient) GetSecret(ctx context.Context, s string) ([]byte, error) {
	var sec map[string]interface{}
	var err error
	terr := vc.NewToken(ctx)
	if terr != nil {
		return nil, terr
	}
	sec, err = vc.GetKVSecretOnce(ctx, s)
	if err != nil {
		terr := vc.NewToken(ctx)
		if terr != nil {
			return nil, terr
		}
		sec, err = vc.GetKVSecretOnce(ctx, s)
		if err != nil {
			return nil, err
		}
	}
	b, err := json.Marshal(sec)
	if err != nil {
		return nil, err
	}
	return b, err
}

// WriteSecret will login and retry secret write on failure
// to gracefully handle token expiration
func (vc *VaultClient) WriteSecret(ctx context.Context, meta metav1.ObjectMeta, s string, bData []byte) ([]byte, error) {
	l := log.WithFields(log.Fields{
		"address": vc.Address,
		"role":    vc.Role,
		"path":    s,
		"method":  vc.AuthMethod,
	})
	var data map[string]interface{}
	err := json.Unmarshal(bData, &data)
	if err != nil {
		return nil, err
	}
	var secrets map[string]interface{}
	if vc.Merge {
		sec, err := vc.GetSecret(ctx, s)
		if err != nil {
			return nil, err
		}
		var secd map[string]interface{}
		err = json.Unmarshal(sec, &secd)
		if err != nil {
			return nil, err
		}
		for k, v := range data {
			secd[k] = v
		}
		data = secd
	}
	terr := vc.NewToken(ctx)
	if terr != nil {
		return nil, terr
	}
	secrets, err = vc.WriteSecretOnce(ctx, s, data)
	if err != nil {
		terr := vc.NewToken(ctx)
		if terr != nil {
			return nil, terr
		}
		secrets, err = vc.WriteSecretOnce(ctx, s, data)
		if err != nil {
			return nil, err
		}
	}
	l.Tracef("secrets=%+v", secrets)
	return nil, err
}

// WriteSecret writes a secret to Vault VaultClient at path p with secret value s
func (vc *VaultClient) WriteSecretOnce(ctx context.Context, p string, s map[string]interface{}) (map[string]interface{}, error) {
	var secrets map[string]interface{}
	pp := strings.Split(p, "/")
	if len(pp) < 2 {
		return secrets, errors.New("secret path must be in kv/path/to/secret format")
	}
	pp = insertSliceString(pp, 1, "data")
	p = strings.Join(pp, "/")
	if s == nil {
		return secrets, errors.New("secret data required")
	}
	if p == "" {
		return secrets, errors.New("secret path required")
	}
	vd := map[string]interface{}{
		"data": s,
	}
	_, err := vc.Client.Logical().WriteWithContext(ctx, p, vd)
	if err != nil {
		return secrets, err
	}
	return secrets, nil
}

// DeleteSecret deletes a secret from path p
func (vc *VaultClient) DeleteSecret(ctx context.Context, p string) error {
	l := log.WithFields(log.Fields{
		"address": vc.Address,
		"role":    vc.Role,
		"path":    p,
		"method":  vc.AuthMethod,
	})
	if p == "" {
		return errors.New("secret path required")
	}
	pp := strings.Split(p, "/")
	if len(pp) < 2 {
		return errors.New("secret path must be in kv/path/to/secret format")
	}
	if !strings.Contains(p, "/metadata/") {
		pp = insertSliceString(pp, 1, "metadata")
		p = strings.Join(pp, "/")
	}
	terr := vc.NewToken(ctx)
	if terr != nil {
		return terr
	}
	_, err := vc.Client.Logical().DeleteWithContext(ctx, p)
	if err != nil {
		l.WithFields(log.Fields{
			"error": err,
		}).Error("vault.DeleteSecret")
		return err
	}
	l.Debug("secret deleted")
	return nil
}

func (vc *VaultClient) ListSecretsOnce(ctx context.Context, p string) ([]string, error) {
	if vc == nil || vc.Client == nil {
		return nil, errors.New("vault client not initialized")
	}
	if p == "" {
		return nil, errors.New("secret path required")
	}
	pp := strings.Split(p, "/")
	if len(pp) < 2 {
		return nil, errors.New("secret path must be in kv/path/to/secret format")
	}
	pp = insertSliceString(pp, 1, "metadata")
	p = strings.Join(pp, "/")
	l := log.WithFields(log.Fields{
		"address": vc.Address,
		"role":    vc.Role,
		"path":    p,
		"method":  vc.AuthMethod,
	})
	l.Debug("vault.ListSecrets")
	if !strings.HasSuffix(p, "/") {
		p = p + "/"
	}
	secret, err := vc.Client.Logical().ListWithContext(ctx, p)
	if err != nil {
		return nil, err
	}
	if secret == nil {
		return nil, nil
	}
	k := secret.Data["keys"].([]interface{})
	var keys []string
	for _, v := range k {
		keys = append(keys, v.(string))
	}
	return keys, nil
}

func (vc *VaultClient) ListSecrets(ctx context.Context, p string) ([]string, error) {
	var keys []string
	var err error
	terr := vc.NewToken(ctx)
	if terr != nil {
		return keys, terr
	}
	keys, err = vc.ListSecretsOnce(ctx, p)
	if err != nil {
		terr := vc.NewToken(ctx)
		if terr != nil {
			return keys, terr
		}
		keys, err = vc.ListSecretsOnce(ctx, p)
		if err != nil {
			return keys, err
		}
	}
	return keys, err
}

func (c *VaultClient) Close() error {
	c.Client.ClearToken()
	return nil
}

func (c *VaultClient) SetDefaults(defaults any) error {
	dv, err := json.Marshal(defaults)
	if err != nil {
		return err
	}
	dc := &VaultClient{}
	err = json.Unmarshal(dv, dc)
	if err != nil {
		return err
	}
	if c.Address == "" && dc.Address != "" {
		c.Address = dc.Address
	}
	if c.CIDR == "" && dc.CIDR != "" {
		c.CIDR = dc.CIDR
	}
	if c.AuthMethod == "" && dc.AuthMethod != "" {
		c.AuthMethod = dc.AuthMethod
	}
	if c.Namespace == "" && dc.Namespace != "" {
		c.Namespace = dc.Namespace
	}
	if c.Role == "" && dc.Role != "" {
		c.Role = dc.Role
	}
	if c.TTL == "" && dc.TTL != "" {
		c.TTL = dc.TTL
	}
	return nil
}
